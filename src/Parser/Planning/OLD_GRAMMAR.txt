%{

	#include <stdio.h>

	FILE *yyin;

	int yyerror();
	extern int yylex();

%}

%union {
	int intval;
	float floatval;
	char* str;
};

/* Token Definitions */
%token 
	
	ASSIGN "="
	
	/* Arithmetic */
	PLUS				"+"
	MINUS				"-"
	MULT				"*"
	DIV					"/"
	MOD					"%"
	PLUS_EQUALS			"+="
	MINUS_EQUALS		"-="
	MULT_EQUALS			"*="
	DIV_EQUALS			"/="
	MOD_EQUALS			"%="
	INCREMENT			"++"
	DECREMENT			"--"

	/* Boolean */
	GREATER				">"
	GREATER_EQUAL		">="
	LESS				"<"
	LESS_EQUAL			"<="
	EQUIVALENT			"=="
	NOT_EQUIVALENT		"!="
	AND					"&&"
	OR					"||"
	NOT					"!"

	/* Punctuators */
	SEMICOLON			";"
	COLON				":"
	COMMA				","
	OPENPAREN			"("
	CLOSEPAREN			")"
	OPENCURLY			"{"
	CLOSECURLY			"}"
	OPENSQUARE			"["
	CLOSESQUARE			"]"

	/* Keywords */
	LET					"let"
	INT_TYPE			"int"
	STRING_TYPE			"string"
	FLOAT_TYPE			"float"
	LIST_TYPE			"list"
	IF					"if"
	WHILE				"while"
	FN					"fn"
	RETURN				"return"


	/* Literals */
	INT_LITERAL<intval>
	FLOAT_LITERAL<floatval>
	STRING_LITERAL

	IDENTIFIER


/* Precedences */


/* Rules */
%% 

Program: | Function Program;

Function: "fn" IDENTIFIER "(" Parameters ")" ":" DataType CompoundStatement;
Parameters: | Parameter;
Parameter: 
	| IDENTIFIER ":" DataType "," Parameter 
	| IDENTIFIER ":" DataType;

DataType: "int" | "string" | "float" | ListType;
ListType: "list" "[" DataType "]";

CompoundStatement: "{" Statements "}";
Statements: | Statement Statements;
Statement:
	  "if" "(" Expression ")" CompoundStatement
	| "while" "(" Expression ")" CompoundStatement
	| "return" Expression ";"
	| "let" IDENTIFIER ":" DataType "=" Expression ";"
	| Expression ";"

Expression:
	  INT_LITERAL
	| STRING_LITERAL
	| FLOAT_LITERAL
	| "[" ListLiteral "]"
	| IDENTIFIER
	| "(" Expression ")"
	| Expression "[" Expression "]"
	| Expression "(" Arguements ")"
	| Expression "+" Expression
	| Expression "-" Expression
	| Expression "*" Expression
	| Expression "/" Expression
	| Expression "%" Expression
	| Expression "+=" Expression
	| Expression "-=" Expression
	| Expression "*=" Expression
	| Expression "/=" Expression
	| Expression "%=" Expression
	| Expression ">" Expression
	| Expression ">=" Expression
	| Expression "<" Expression
	| Expression "<=" Expression
	| Expression "==" Expression
	| Expression "!=" Expression
	| Expression "&&" Expression
	| Expression "||" Expression
	| "!"  Expression
	| "++" Expression
	| "--" Expression
	| Expression "++"
	| Expression "--"
	;

Arguements: | Arguement;
Arguement: Expression | Expression "," Arguement;

ListLiteral: Expression | Expression "," ListLiteral;

/* Driver Program */
%%

int parser_main(int argc, char* argv[])
{
	
	if (argc == 0)
	{
		printf("ERROR: No file");
		exit(1);
	}

	FILE *file;
	fopen_s(&file, argv[0], "r");
	if (file) {
		yyin = file;
	} else {
		perror("Failed to open file.");
		exit(-1);
	}

	yyparse();

	if (file != NULL)
	{
		fclose(file);
	}

	return 0;
}

yyerror(char* s)
{
	fprintf(stderr, "ERROR: %s\n", s);
	exit(-1);
	return 0;
}




// LEXER //

%{
	/* Definitions */
	#include "Parser.tab.h"

	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>

	#define fileno _fileno

	int lineNumber = 1;

%}

%option noyywrap

digit		[0-9]
letter		[a-zA-Z]
identifer	{letter}+
whitespace	[ \t]+


%x c_comment


/* Rules */
%%


{whitespace} {}
\n { lineNumber++; }
"/*"					{ BEGIN(c_comment); }
<c_comment>\n			{ lineNumber++; }
<c_comment>.*"*/"       { BEGIN(INITIAL); }
<c_comment>.*	        { }
"//".* { }


"="				{ return ASSIGN;			}
"+"				{ return PLUS;				}
"-"				{ return MINUS;				}
"*"				{ return MULT;				}
"/"				{ return DIV;				}
"%"				{ return MOD;				}
"+="			{ return PLUS_EQUALS;		}
"-="			{ return MINUS_EQUALS;		}
"*="			{ return MULT_EQUALS;		}
"/="			{ return DIV_EQUALS;		}
"%="			{ return MOD_EQUALS;		}
"++"			{ return INCREMENT;			}
"--"			{ return DECREMENT;			}

">"				{ return GREATER;			}
">="			{ return GREATER_EQUAL;		}
"<"				{ return LESS;				}
"<="			{ return LESS_EQUAL;		}
"=="			{ return EQUIVALENT;		}
"!="			{ return NOT_EQUIVALENT;	}
"&&"			{ return AND;				}
"||"			{ return OR;				}
"!"				{ return NOT;				}

";"				{ return SEMICOLON;			}
":"				{ return COLON;				}
","				{ return COMMA;				}
"("				{ return OPENPAREN;			}
")"				{ return CLOSEPAREN;		}
"["				{ return OPENSQUARE;		}
"]"				{ return CLOSEPAREN;		}
"{"				{ return OPENCURLY;			}
"}"				{ return CLOSECURLY;		}

"let"			{ return LET;				}
"int"			{ return INT_TYPE;			}
"string"		{ return STRING_TYPE;		}
"float"			{ return FLOAT_TYPE;		}
"list"			{ return LIST_TYPE;			}
"if"			{ return IF;				}
"while"			{ return WHILE;				}
"fn"			{ return FN;				}
"return"		{ return RETURN;			}

\".*\"				{ return STRING_LITERAL;								}
{digit}+			{ yylval.intval = atoi(yytext); return INT_LITERAL;		}
{digit}+.{digit}+	{ yylval.floatval = atof(yytext); return FLOAT_LITERAL;	}

{letter}({letter}|{digit})* { return IDENTIFIER;	}

. {
	fprintf(stderr, "ERROR: Token Error at line %d", lineNumber);
	exit(-1);
}

%%
