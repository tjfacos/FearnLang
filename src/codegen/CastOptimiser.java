package codegen;

import static org.objectweb.asm.Opcodes.*;
import org.objectweb.asm.tree.*;

/* CastOptimiser.java
 * 
 * This class exists to eliminate redundant bytecode.
 * 
 * During development, I decided to enforce the rule that
 * expressions should return the object version of their 
 * values, rather than primitives, as they are (in general)
 * easier to work with - as it requires less decision cross-node
 * decision making on which instruction to use (JVM instructions 
 * are often typed).
 * 
 * The downside of this was the bytecode produced was often 
 * inefficient, since a child node would cast its primitive return 
 * value to an object, and the parent node would immediately cast 
 * it back. 
 * 
 * My solution to this is below. The method EliminateRedundantCasts
 * iterates through the generated bytecode instructions, in the 
 * MethodNode used to generate a function. It then detects when
 * two sequential casts have occurred, and eliminates both. Since
 * these instructions were casting from primitive, to object, and
 * back again, eliminating them has no affect on program functionality,
 * but does make execution faster, more efficient, and makes the binaries
 * smaller.
 * 
 */

public class CastOptimiser {

    /**
     * EliminateRedundantCasts
     * 
     * This method iterates through the bytecode instructions of a 
     * MethodNode, and removes any redundant casts. 
     * 
     * @param node The MethodNode to optimise
     */
    public static void EliminateRedundantCasts(MethodNode node)
    {
        // Iterate through each instruction in function's MethodNode
        for (int i = 0; i < node.instructions.size(); i++)
        {
            AbstractInsnNode current_insn = node.instructions.get(i);
            
            // Check for redundant int casting (check for the descriptor 
            // for casting from primitive int to Integer object)
            if (
                current_insn.getOpcode() == INVOKESTATIC 
                && ((MethodInsnNode)current_insn).desc.equals("(I)Ljava/lang/Integer;")
            ) {
                // Check if next instruction is casting straight back (by checking descriptor)
                AbstractInsnNode next_insn = node.instructions.get(i + 1);
                if (
                    next_insn.getOpcode() == INVOKEVIRTUAL 
                    && ((MethodInsnNode)next_insn).desc.equals("()I")
                ) {
                    // Remove both instructions
                    node.instructions.remove(current_insn);
                    node.instructions.remove(next_insn);

                    // Decrement index to stay at same location next iteration
                    i--;
                    continue;
                }
            }

            // Check for redundant bool casting (same procedure as int, refactored for primitive Z and Boolean object)
            if (
                current_insn.getOpcode() == INVOKESTATIC 
                && ((MethodInsnNode)current_insn).desc.equals("(Z)Ljava/lang/Boolean;")
            ) {
                AbstractInsnNode next_insn = node.instructions.get(i + 1);
                if (
                    next_insn.getOpcode() == INVOKEVIRTUAL 
                    && ((MethodInsnNode)next_insn).desc.equals("()Z")
                ) {
                    // Remove both instructions
                    node.instructions.remove(current_insn);
                    node.instructions.remove(next_insn);

                    // Decrement index to stay at same location
                    i--;
                    continue;
                }
            }

            // Check for redundant double casting (same procedure as int, refactored for primitive D and Double object)
            if (
                current_insn.getOpcode() == INVOKESTATIC 
                && ((MethodInsnNode)current_insn).desc.equals("(D)Ljava/lang/Double;")
            ) {
                AbstractInsnNode next_insn = node.instructions.get(i + 1);
                if (
                    next_insn.getOpcode() == INVOKEVIRTUAL 
                    && ((MethodInsnNode)next_insn).desc.equals("()D")
                ) {
                    // Remove both instructions
                    node.instructions.remove(current_insn);
                    node.instructions.remove(next_insn);

                    // Decrement index to stay at same location
                    i--;
                    continue;
                }
            }

        }

    }
}

